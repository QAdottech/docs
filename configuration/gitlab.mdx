---
title: GitLab CI/CD
description: 'Integrate QA.tech testing into GitLab pipelines'
icon: 'gitlab'
---

Trigger QA.tech test runs from your GitLab CI/CD pipelines using the REST API.

<Note>
AI-powered exploratory testing is currently GitHub-only via the [GitHub App](/configuration/github-app). For GitLab, use API-driven testing as described below.
</Note>

## Setup

### Prerequisites

You need two values from your [project settings](https://app.qa.tech/current-project/settings/integrations):

- **API Token** - Your QA.tech API token
- **Test Plan Short ID** - Prefixed ID from your test plan (e.g. `pln_abc123`)

### Configure CI/CD Variables

Store your API token securely:

1. Go to **Settings → CI/CD → Variables**
2. Add variable:
   - **Key**: `QA_TECH_API_TOKEN`
   - **Value**: Your API token
   - **Protected**: ✅
   - **Masked**: ✅

## Implementation Patterns

### Basic Setup

```yaml
trigger_qatech:
  stage: test
  variables:
    API_TOKEN: $QA_TECH_API_TOKEN
    QATECH_REQUEST_BODY: '{"testPlanShortId": "pln_abc123"}'
  script: >
    curl --request POST
    --url "https://api.qa.tech/v1/run"
    --header "Authorization: Bearer $API_TOKEN"
    --header "Content-Type: application/json"
    --data "${QATECH_REQUEST_BODY}"
```

Replace `pln_abc123` with your test plan short ID (see Settings).

### Run on Merge Requests

```yaml
test_mr:
  stage: test
  only:
    - merge_requests
  variables:
    API_TOKEN: $QA_TECH_API_TOKEN
    QATECH_REQUEST_BODY: '{"testPlanShortId": "pln-smoke-tests_abc123"}'
  script: >
    curl --request POST
    --url "https://api.qa.tech/v1/run"
    --header "Authorization: Bearer $API_TOKEN"
    --header "Content-Type: application/json"
    --data "${QATECH_REQUEST_BODY}"
```

### Test Preview Deployments

Pass dynamic URLs between jobs using dotenv artifacts:

```yaml
stages:
  - deploy
  - test

deploy_preview:
  stage: deploy
  script:
    - echo "PREVIEW_URL=https://preview-${CI_MERGE_REQUEST_IID}.yourdomain.com" >> deploy.env
  artifacts:
    reports:
      dotenv: deploy.env

test_preview:
  stage: test
  dependencies:
    - deploy_preview
  variables:
    API_TOKEN: $QA_TECH_API_TOKEN
  before_script:
    - |
      echo '{"testPlanShortId":"pln_regression-suite","applications":[{"applicationShortId":"app_frontend","environment":{"url":"'$PREVIEW_URL'","name":"MR-'$CI_MERGE_REQUEST_IID'"}}]}' > /tmp/request.json
  script: >
    curl --request POST
    --url "https://api.qa.tech/v1/run"
    --header "Authorization: Bearer $API_TOKEN"
    --header "Content-Type: application/json"
    --data @/tmp/request.json
```

<Note>
You can also override device presets in the same request by adding `devicePresetShortId` to each application object in the `applications` array. For example, to test the preview deployment on a mobile device preset: `"applications":[{"applicationShortId":"app_frontend","environment":{"url":"'$PREVIEW_URL'"},"devicePresetShortId":"preset_abc123"}]`. See [Start Run API](/api-reference/start-run) for details.
</Note>

### Scheduled Testing

```yaml
nightly_tests:
  stage: test
  only:
    - schedules
  variables:
    API_TOKEN: $QA_TECH_API_TOKEN
    QATECH_REQUEST_BODY: '{"testPlanShortId": "pln_full-regression"}'
  script: >
    curl --request POST
    --url "https://api.qa.tech/v1/run"
    --header "Authorization: Bearer $API_TOKEN"
    --header "Content-Type: application/json"
    --data "${QATECH_REQUEST_BODY}"
```

Set up schedules at **CI/CD → Schedules → New schedule**.

<Accordion title="GitLab Schedules vs QA.tech Schedules">
**Use GitLab schedules when:**
- Tests should run as part of your CI/CD pipeline
- You need GitLab context (branch, commit SHA)
- You want to gate deployments on scheduled test results

**Use QA.tech schedules when:**
- Tests should run independently of CI/CD infrastructure
- You prefer managing schedules in QA.tech UI
- You want to avoid consuming GitLab runner minutes

See [Test Plans](/core-concepts/test-plans#scheduled-execution) for QA.tech scheduling.
</Accordion>

## GitLab Tips

### Finding Your Test Plan Short ID

1. Go to [Test Plans](https://app.qa.tech/current-project/test-plans)
2. Click on a test plan
3. Check the URL: `https://app.qa.tech/.../test-plans/abc123`
4. The short ID is `pln_abc123` (add the `pln_` prefix)

### Building JSON Payloads

For complex payloads with dynamic values, write to a file first:

```yaml
before_script:
  - |
    echo '{"key": "'$VARIABLE'"}' > /tmp/request.json
script:
  - curl ... --data @/tmp/request.json
```

### Custom Slack Notifications

Override notification channels per-run. See [Notifications](/core-concepts/notifications#per-run-api-overrides-slack-only) for details.

### Blocking Mode

Wait for test completion before proceeding with deployments:

```yaml
trigger_qatech:
  stage: test
  variables:
    API_TOKEN: $QA_TECH_API_TOKEN
  script:
    # Start run and capture shortId
    - |
      RESPONSE=$(curl -s -X POST \
        "https://api.qa.tech/v1/run" \
        -H "Authorization: Bearer $API_TOKEN" \
        -H "Content-Type: application/json" \
        -d "{\"testPlanShortId\": \"pln_abc123\"}")
      SHORT_ID=$(echo "$RESPONSE" | jq -r '.run.shortId')
    
    # Poll until completion (see Run Status API for details)
    - |
      while true; do
        RESPONSE=$(curl -s \
          "https://api.qa.tech/v1/run/$SHORT_ID" \
          -H "Authorization: Bearer $API_TOKEN")
        STATUS=$(echo "$RESPONSE" | jq -r '.status')
        if [[ "$STATUS" == "COMPLETED" || "$STATUS" == "ERROR" || "$STATUS" == "CANCELLED" ]]; then
          RESULT=$(echo "$RESPONSE" | jq -r '.result')
          [[ "$RESULT" == "PASSED" ]] && exit 0 || exit 1
        fi
        sleep 30
      done
```

See [Run Status API](/api-reference/run-status) for polling logic details and error handling.

## Related Documentation

- **[CI/CD Integration](/configuration/ci-cd-integration)** - Overview of integration modes
- **[API Reference](/api-reference/start-run)** - Complete API documentation
- **[Test Plans](/core-concepts/test-plans)** - Create and organize test plans
- **[Preview Environments](/core-concepts/applications-and-environments#preview-environments)** - Dynamic preview testing
